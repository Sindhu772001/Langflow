{"name": "Classify_DMS", "description": "Empowering Language Engineering.", "icon": null, "icon_bg_color": null, "gradient": null, "data": {"nodes": [{"id": "Prompt-TI8xV", "type": "genericNode", "position": {"x": -335.92897498926095, "y": -526.4938446372876}, "data": {"node": {"template": {"_type": "Component", "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "template": {"tool_mode": false, "trace_as_input": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "template", "value": "You are an expert Freight Forwarding email classifier. Your task is to classify emails into one of the following categories based on their content. Each category has specific criteria, and missing mandatory fields should be reported accurately.\n\nClassification Categories:\n1. RateCloud:\n   Classify the email as \"RateCloud\" if it contains keywords such as:\n   - \"Quotation Details\"\n   - \"Route Details\"\n   - \"Freight Charges\"\n   - \"Surcharges\"\n   - \"Additional Notes\"\n   - \"Recipient Information\"\n   Even if the email includes the keyword \"enquiry\" or is related to it, if the above keywords are present, it should still be classified as \"RateCloud.\"\n\n2. Enquiry:\n   Classify the email as \"Enquiry\" if it requests an inquiry, is related to a quote request, or contains the keyword \"RFQ.\"\n   The email contains keywords related to inquiries such as:\n   - \"shipping cost\"\n   - \"transit time\"\n   - \"documentation\"\n   - \"insurance options\"\n   - \"quote request\"\n   - \"additional services\"\n   The email is requesting details or information about shipping, including costs, transit time, documentation, insurance, and services.\n\n3. Helpdesk:\n   Classify the email as \"Helpdesk\" if it involves any of the following issues:\n   - \"Status inquiry for shipment\"\n   - \"Incorrect delivery location or delay\"\n   - \"Incorrect items received\"\n   - \"Incorrect tracking information\"\n   - \"Complaints regarding damaged shipments\"\n   - \"Poor customer service\"\n\n4. OrderFulfillment:\n   Classify the email as \"OrderFulfillment\" if it provides updates or information about the logistics process, such as:\n   - Shipment tracking\n   - Booking details\n   - Delivery statuses\n   - Tracking information\n\nRequired Fields for Classification:\n\nFor Enquiry (only these fields will be retrieved for Enquiry classification):\n- contentPresentEnquiry: Check if the email contains enquiry-related content such as RFQ, inquiry, or quote request.\n  - Set the value to \"Yes\" if present.\n  - Otherwise, leave it as an empty string.\n  \n- enquiryType: Determine whether the enquiry is related to a single destination or multiple destinations.\n  - Set the value to \"single\" if only one destination location is mentioned.\n  - Set the value to \"multiple\" if two or more destination locations are mentioned.\n  - Otherwise, leave it as an empty string.\n  \n- validEnquiry: Assess if the content is related to an enquiry or not.\n  - Set the value to \"Yes\" if it is a valid enquiry.\n  - If invalid, leave it as an empty string.\n\nFor Helpdesk (only these fields will be retrieved for Helpdesk classification):\n- issueType: Analyze the email and classify the type of issue.\n  - Set the value to one of the following options:\n    - \"Status Inquiry for Shipment\"\n    - \"Incorrect Delivery Location and Delay\"\n    - \"Incorrect Items Received\"\n    - \"Incorrect Tracking Information\"\n    - \"Complaint Regarding Damaged Shipment\"\n    - \"Poor Customer Service Experience\"\n  - Otherwise, leave it as an empty string.\n\nOutput Structure:\nThe output should structured as follows:\n\n[\n    {{\"mailType\": \"\"}},\n    {{\"contentPresentEnquiry\": \"\"}},\n    {{\"enquiryType\": \"\"}},\n    {{\"validEnquiry\": \"\"}},\n    {{\"issueType\": \"\"}}\n]\n\n\n- Strictly follow the above output format. If any of the values are not available, leave them as blank or \"NA\". Don't provide any explanation and add any extra fields.\n- Return only the above json format and not any other explanation\n{content}", "display_name": "Template", "advanced": false, "dynamic": false, "info": "", "title_case": false, "type": "prompt", "_input_type": "PromptInput"}, "tool_placeholder": {"tool_mode": true, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "tool_placeholder", "value": "", "display_name": "Tool Placeholder", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "A placeholder input for tool mode.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "content": {"field_type": "str", "required": false, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "", "fileTypes": [], "file_path": "", "name": "content", "display_name": "content", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "", "load_from_db": false, "title_case": false, "type": "str"}}, "description": "Create a prompt template with dynamic variables.", "icon": "prompts", "is_input": null, "is_output": null, "is_composition": null, "base_classes": ["Message"], "name": "", "display_name": "Prompt", "documentation": "", "minimized": false, "custom_fields": {"template": ["content"]}, "output_types": [], "full_path": null, "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "prompt", "hidden": null, "display_name": "Prompt Message", "method": "build_prompt", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "tool_mode": true}], "field_order": ["template", "tool_placeholder"], "beta": false, "legacy": false, "error": null, "edited": false, "metadata": {}, "tool_mode": false, "lf_version": "1.1.5"}, "showNode": true, "type": "Prompt", "id": "Prompt-TI8xV"}, "selected": false, "measured": {"width": 320, "height": 337}, "dragging": false}, {"id": "OpenAIModel-bcpME", "type": "genericNode", "position": {"x": 111.10567703727861, "y": -771.5854841668544}, "data": {"node": {"template": {"_type": "Component", "api_key": {"load_from_db": false, "required": true, "placeholder": "", "show": true, "name": "api_key", "value": null, "display_name": "OpenAI API Key", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "The OpenAI API Key to use for the OpenAI model.", "title_case": false, "password": true, "type": "str", "_input_type": "SecretStrInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.base.models.openai_constants import OPENAI_MODEL_NAMES\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs import BoolInput, DictInput, DropdownInput, IntInput, SecretStrInput, SliderInput, StrInput\n\n\nclass OpenAIModelComponent(LCModelComponent):\n    display_name = \"OpenAI\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAIModel\"\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(\n            name=\"model_kwargs\",\n            display_name=\"Model Kwargs\",\n            advanced=True,\n            info=\"Additional keyword arguments to pass to the model.\",\n        ),\n        BoolInput(\n            name=\"json_mode\",\n            display_name=\"JSON Mode\",\n            advanced=True,\n            info=\"If True, it will output JSON regardless of passing a schema.\",\n        ),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            options=OPENAI_MODEL_NAMES,\n            value=OPENAI_MODEL_NAMES[0],\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            advanced=True,\n            info=\"The base URL of the OpenAI API. \"\n            \"Defaults to https://api.openai.com/v1. \"\n            \"You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            advanced=False,\n            value=\"OPENAI_API_KEY\",\n            required=True,\n        ),\n        SliderInput(\n            name=\"temperature\", display_name=\"Temperature\", value=0.1, range_spec=RangeSpec(min=0, max=1, step=0.01)\n        ),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n        IntInput(\n            name=\"max_retries\",\n            display_name=\"Max Retries\",\n            info=\"The maximum number of retries to make when generating.\",\n            advanced=True,\n            value=5,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            info=\"The timeout for requests to OpenAI completion API.\",\n            advanced=True,\n            value=700,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        openai_api_key = self.api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        max_tokens = self.max_tokens\n        model_kwargs = self.model_kwargs or {}\n        openai_api_base = self.openai_api_base or \"https://api.openai.com/v1\"\n        json_mode = self.json_mode\n        seed = self.seed\n        max_retries = self.max_retries\n        timeout = self.timeout\n\n        api_key = SecretStr(openai_api_key).get_secret_value() if openai_api_key else None\n        output = ChatOpenAI(\n            max_tokens=max_tokens or None,\n            model_kwargs=model_kwargs,\n            model=model_name,\n            base_url=openai_api_base,\n            api_key=api_key,\n            temperature=temperature if temperature is not None else 0.1,\n            seed=seed,\n            max_retries=max_retries,\n            request_timeout=timeout,\n        )\n        if json_mode:\n            output = output.bind(response_format={\"type\": \"json_object\"})\n\n        return output\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an OpenAI exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "input_value": {"trace_as_input": true, "tool_mode": false, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "input_value", "value": "", "display_name": "Input", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "MessageInput"}, "json_mode": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "json_mode", "value": false, "display_name": "JSON Mode", "advanced": true, "dynamic": false, "info": "If True, it will output JSON regardless of passing a schema.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "max_retries": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "max_retries", "value": 5, "display_name": "Max Retries", "advanced": true, "dynamic": false, "info": "The maximum number of retries to make when generating.", "title_case": false, "type": "int", "_input_type": "IntInput"}, "max_tokens": {"tool_mode": false, "trace_as_metadata": true, "range_spec": {"step_type": "float", "min": 0, "max": 128000, "step": 0.1}, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "max_tokens", "value": "", "display_name": "Max Tokens", "advanced": true, "dynamic": false, "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.", "title_case": false, "type": "int", "_input_type": "IntInput"}, "model_kwargs": {"tool_mode": false, "trace_as_input": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "model_kwargs", "value": {}, "display_name": "Model Kwargs", "advanced": true, "dynamic": false, "info": "Additional keyword arguments to pass to the model.", "title_case": false, "type": "dict", "_input_type": "DictInput"}, "model_name": {"tool_mode": false, "trace_as_metadata": true, "options": ["gpt-4o-mini", "gpt-4o", "gpt-4-turbo", "gpt-4-turbo-preview", "gpt-4", "gpt-3.5-turbo", "gpt-3.5-turbo-0125"], "options_metadata": [], "combobox": false, "dialog_inputs": {}, "required": false, "placeholder": "", "show": true, "name": "model_name", "value": "unsloth-llama3.1", "display_name": "Model Name", "advanced": false, "dynamic": false, "info": "", "title_case": false, "type": "str", "_input_type": "DropdownInput", "load_from_db": false}, "openai_api_base": {"tool_mode": false, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "openai_api_base", "value": "https://dev-vllm-unsloth.bautomate.com/v1", "display_name": "OpenAI API Base", "advanced": false, "dynamic": false, "info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.", "title_case": false, "type": "str", "_input_type": "StrInput"}, "seed": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "seed", "value": 1, "display_name": "Seed", "advanced": true, "dynamic": false, "info": "The seed controls the reproducibility of the job.", "title_case": false, "type": "int", "_input_type": "IntInput"}, "stream": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "stream", "value": false, "display_name": "Stream", "advanced": false, "dynamic": false, "info": "Stream the response from the model. Streaming works only in Chat.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "system_message": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "system_message", "value": "admin", "display_name": "System Message", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "System message to pass to the model.", "title_case": false, "type": "str", "_input_type": "MultilineInput"}, "temperature": {"tool_mode": false, "min_label": "", "max_label": "", "min_label_icon": "", "max_label_icon": "", "slider_buttons": false, "slider_buttons_options": [], "slider_input": false, "range_spec": {"step_type": "float", "min": 0, "max": 1, "step": 0.01}, "required": false, "placeholder": "", "show": true, "name": "temperature", "value": 0.1, "display_name": "Temperature", "advanced": false, "dynamic": false, "info": "", "title_case": false, "type": "slider", "_input_type": "SliderInput"}, "timeout": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "timeout", "value": 700, "display_name": "Timeout", "advanced": true, "dynamic": false, "info": "The timeout for requests to OpenAI completion API.", "title_case": false, "type": "int", "_input_type": "IntInput"}}, "description": "Generates text using OpenAI LLMs.", "icon": "OpenAI", "base_classes": ["LanguageModel", "Message"], "display_name": "OpenAI", "documentation": "", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "text_output", "hidden": null, "display_name": "Message", "method": "text_response", "value": "__UNDEFINED__", "cache": true, "required_inputs": [], "allows_loop": false, "tool_mode": true}, {"types": ["LanguageModel"], "selected": "LanguageModel", "name": "model_output", "hidden": null, "display_name": "Language Model", "method": "build_model", "value": "__UNDEFINED__", "cache": true, "required_inputs": ["api_key"], "allows_loop": false, "tool_mode": true}], "field_order": ["input_value", "system_message", "stream", "max_tokens", "model_kwargs", "json_mode", "model_name", "openai_api_base", "api_key", "temperature", "seed", "max_retries", "timeout"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "lf_version": "1.1.5"}, "showNode": true, "type": "OpenAIModel", "id": "OpenAIModel-bcpME", "description": "Generates text using OpenAI LLMs.", "display_name": "OpenAI"}, "selected": false, "measured": {"width": 320, "height": 735}, "dragging": false}, {"id": "JSONCleaner-mnhzp", "type": "genericNode", "position": {"x": 599.9087148892688, "y": -673.841604866304}, "data": {"node": {"template": {"_type": "Component", "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "import json\nimport unicodedata\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, MessageTextInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass JSONCleaner(Component):\n    icon = \"braces\"\n    display_name = \"JSON Cleaner\"\n    description = (\n        \"Cleans the messy and sometimes incorrect JSON strings produced by LLMs \"\n        \"so that they are fully compliant with the JSON spec.\"\n    )\n\n    inputs = [\n        MessageTextInput(\n            name=\"json_str\", display_name=\"JSON String\", info=\"The JSON string to be cleaned.\", required=True\n        ),\n        BoolInput(\n            name=\"remove_control_chars\",\n            display_name=\"Remove Control Characters\",\n            info=\"Remove control characters from the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"normalize_unicode\",\n            display_name=\"Normalize Unicode\",\n            info=\"Normalize Unicode characters in the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"validate_json\",\n            display_name=\"Validate JSON\",\n            info=\"Validate the JSON string to ensure it is well-formed.\",\n            required=False,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Cleaned JSON String\", name=\"output\", method=\"clean_json\"),\n    ]\n\n    def clean_json(self) -> Message:\n        try:\n            from json_repair import repair_json\n        except ImportError as e:\n            msg = \"Could not import the json_repair package. Please install it with pip install json_repair.\"\n            raise ImportError(msg) from e\n\n        \"\"\"Clean the input JSON string based on provided options and return the cleaned JSON string.\"\"\"\n        json_str = self.json_str\n        remove_control_chars = self.remove_control_chars\n        normalize_unicode = self.normalize_unicode\n        validate_json = self.validate_json\n\n        # Clean the string first\n        if remove_control_chars:\n            json_str = self._remove_control_characters(json_str)\n        if normalize_unicode:\n            json_str = self._normalize_unicode(json_str)\n\n        # Repair JSON if needed\n        cleaned_json_str = repair_json(json_str)\n        \n        # Parse the JSON into a Python object\n        try:\n            json_data = json.loads(cleaned_json_str)\n        except json.JSONDecodeError as e:\n            msg = f\"Failed to parse JSON after repair: {e}\"\n            raise ValueError(msg) from e\n\n        # If it's an array of single-key objects, merge into a single dict\n        if isinstance(json_data, list):\n            merged_dict = {}\n            for item in json_data:\n                if isinstance(item, dict) and len(item) == 1:\n                    key, value = next(iter(item.items()))\n                    merged_dict[key] = value\n                else:\n                    msg = \"Array contains non-single-key objects\"\n                    raise ValueError(msg)\n            json_data = merged_dict\n\n        # Validate if requested\n        if validate_json:\n            try:\n                json.dumps(json_data)  # Ensures it\u2019s serializable\n            except Exception as e:\n                msg = f\"Invalid JSON after processing: {e}\"\n                raise ValueError(msg) from e\n\n        # Convert back to a JSON string\n        result = json.dumps(json_data)\n        self.status = result\n        return Message(text=result)\n\n    def _remove_control_characters(self, s: str) -> str:\n        \"\"\"Remove control characters from the string.\"\"\"\n        return s.translate(self.translation_table)\n\n    def _normalize_unicode(self, s: str) -> str:\n        \"\"\"Normalize Unicode characters in the string.\"\"\"\n        return unicodedata.normalize(\"NFC\", s)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.translation_table = str.maketrans(\"\", \"\", \"\".join(chr(i) for i in range(32)) + chr(127))", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "json_str": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "json_str", "value": "", "display_name": "JSON String", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "The JSON string to be cleaned.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "normalize_unicode": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "normalize_unicode", "value": false, "display_name": "Normalize Unicode", "advanced": false, "dynamic": false, "info": "Normalize Unicode characters in the JSON string.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "remove_control_chars": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "remove_control_chars", "value": false, "display_name": "Remove Control Characters", "advanced": false, "dynamic": false, "info": "Remove control characters from the JSON string.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "validate_json": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "validate_json", "value": false, "display_name": "Validate JSON", "advanced": false, "dynamic": false, "info": "Validate the JSON string to ensure it is well-formed.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}}, "description": "Cleans the messy and sometimes incorrect JSON strings produced by LLMs so that they are fully compliant with the JSON spec.", "icon": "braces", "base_classes": ["Message"], "display_name": "JSON Cleaner", "documentation": "", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "output", "hidden": null, "display_name": "Cleaned JSON String", "method": "clean_json", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "tool_mode": true}], "field_order": ["json_str", "remove_control_chars", "normalize_unicode", "validate_json"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false, "lf_version": "1.1.5"}, "showNode": true, "type": "JSONCleaner", "id": "JSONCleaner-mnhzp"}, "selected": false, "measured": {"width": 320, "height": 395}, "dragging": false}, {"id": "TextInput-BBQPu", "type": "genericNode", "position": {"x": -935.4936468803843, "y": -581.2636096775985}, "data": {"node": {"template": {"_type": "Component", "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def text_response(self) -> Message:\n        return Message(\n            text=self.input_value,\n        )\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "input_value": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "input_value", "value": "{\n    \"mailContent\": \"Subject: Shipment Booking Confirmation \u2013 Tracking #9876543217  Dear John,  We are confirming your shipment from the Port of Miami, FL to 654 River Road, Dallas, TX. Cargo pickup is scheduled for November 14, 2024, with CFS delivery on November 15, 2024. Export clearance will be finalized by November 17, 2024.  The cargo will depart on November 18, 2024, with an arrival at the destination port on November 25, 2024. Final delivery is expected by November 28, 2024.  A minor delay due to customs inspection may cause a slight change in the schedule, but we are managing it efficiently.  The Commercial Invoice Number is INV-889900, and the Bill of Lading Number is BOL-334455. A Certificate of Origin is available on request. The shipment terms are FOB, with payment due before shipment.  Please do not hesitate to contact us for more details.  Best regards,\",\n    \"orgId\": \"143a350f-72ea-47fe-ac10-d749f60eed83\",\n    \"userUniqueId\": \"85d710cb-87d3-4aa3-bdb8-10d6585c0b00\",\n    \"modelType\": \"offline\",\n    \"modelName\": \"llama3\",\n    \"email\": \"kavinn@gmail.com\",\n    \"uuid\" : [\"3efc9421-9b34-4102-b24e-12a51a03c1f5\"]\n\n}", "display_name": "Text", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "Text to be passed as input.", "title_case": false, "type": "str", "_input_type": "MultilineInput"}}, "description": "Get text inputs from the Playground.", "icon": "type", "base_classes": ["Message"], "display_name": "Input JSon", "documentation": "", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "text", "display_name": "Message", "method": "text_response", "value": "__UNDEFINED__", "cache": true, "allows_loop": false}], "field_order": ["input_value"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "lf_version": "1.1.5"}, "showNode": true, "type": "TextInput", "id": "TextInput-BBQPu"}, "selected": false, "measured": {"width": 320, "height": 229}, "dragging": false}, {"id": "DocumentProcessor-w7noZ", "type": "genericNode", "position": {"x": -271.25099594856334, "y": -23.322455666936026}, "data": {"node": {"template": {"_type": "Component", "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "import os\nimport json\nimport asyncio\nimport logging\nfrom aiohttp import request, client_exceptions\nfrom datetime import datetime\nfrom dotenv import load_dotenv\nfrom langflow.custom import Component\nfrom langflow.io import MessageTextInput, Output\nfrom langflow.schema import Data\n\nlogging.basicConfig(level=logging.INFO)\nlog = logging.getLogger(__name__)\n\nclass BookingDmsConnector:\n    def __init__(self):\n        load_dotenv()\n        self.upload_retry_attempts = 0\n        self.download_retry_attempts = 0\n        self.auth_url = \"https://stg2-login.bautomate.com/auth/realms/platform-realm/protocol/openid-connect/token\"\n        self.auth_data = {\n            \"username\": \"adminffqa\",\n            \"password\": \"Adminffqa*1\",\n            \"grant_type\": \"password\",\n            \"scope\": \"openid dms-rest-api email modeler profile ocr-engine bpm-rest-api\",\n            \"client_id\": \"platform-app\"\n        }\n        self.auth_headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n        self.dms_url = \"https://stg2-dms.bautomate.com/dms/document/createSimple\"\n        self.dms_encrypt = \"false\"\n        self.dms_compression = \"false\"\n        self.output_parent_path = \"/okm:root/pythonivr/\"\n        self.dms_create_missing_file = \"true\"\n\n    async def get_auth_token(self):\n        try:\n            log.info('Fetching access token')\n            async with request('POST', self.auth_url, headers=self.auth_headers, data=self.auth_data) as auth_response:\n                auth_response.raise_for_status()\n                response_data = await auth_response.json()\n            access_token = response_data.get('access_token')\n            if not access_token:\n                raise ValueError(\"Access token not found in response\")\n            log.info('Fetched access token..!!')\n            return access_token\n        except Exception as e:\n            log.error(f\"Error in auth token generation: {e}\", exc_info=True)\n            return None\n\n    async def get_dms_download_response(self, bearer_key, file_uuid, download_file_location):\n        try:\n            dms_url = self.dms_url.replace(\"createSimple\", \"content/view?documentId=\") + str(file_uuid) + \"&versionName=1.0\"\n            dms_header = {'Authorization': bearer_key}\n            while self.download_retry_attempts <= 3:\n                async with request('GET', dms_url, headers=dms_header) as response:\n                    if response.status == 200:\n                        log.info('File downloaded from DMS successfully')\n                        file_download_response = await response.content.read()\n                        with open(download_file_location, 'wb') as f:\n                            f.write(file_download_response)\n                        log.info(f\"File Downloaded Location: {download_file_location}\")\n                        return download_file_location\n                    else:\n                        self.download_retry_attempts += 1\n                        log.info(f'DMS download retry attempt: {self.download_retry_attempts}')\n            raise ValueError(f'Invalid Status code: {response.status}')\n        except Exception as e:\n            log.error(f'Error in get_dms_download_response: {e}')\n            return None\n\ndef process_documents(result_json, input_data):\n    log.info(f\"Received result_json: {result_json}, type: {type(result_json)}\")\n    log.info(f\"Received input_data: {input_data}, type: {type(input_data)}\")\n\n    # Ensure inputs are dictionaries\n    if not isinstance(result_json, dict):\n        log.error(\"result_json must be a dictionary\")\n        return json.dumps({\"error\": \"result_json must be a dictionary\"})\n    if not isinstance(input_data, dict):\n        log.error(\"input_data must be a dictionary\")\n        return json.dumps({\"error\": \"input_data must be a dictionary\"})\n\n    uuids = input_data.get(\"uuid\", [])\n    if not uuids:\n        log.error(\"No UUIDs found in input_data\")\n        return json.dumps({\"error\": \"No UUIDs found in input_data\"})\n\n    bkg_dms_sync = BookingDmsConnector()\n    auth_token = asyncio.run(bkg_dms_sync.get_auth_token())\n    if not auth_token:\n        log.error(\"Failed to get auth token\")\n        return json.dumps({\"error\": \"Failed to get auth token\"})\n\n    attachment_paths = []\n    attachment_missing = []\n    valid_attachments = []\n    document_types = []\n\n    download_base_path = \"/tmp/downloads\"\n    os.makedirs(download_base_path, exist_ok=True)\n\n    for uuid in uuids:\n        download_location = os.path.join(download_base_path, f\"{uuid}_document\")\n        log.info(f\"Downloading to: {download_location}\")\n        \n        downloaded_path = asyncio.run(bkg_dms_sync.get_dms_download_response(\n            f'Bearer {auth_token}', uuid, download_location\n        ))\n\n        attachment_missing_value = \"No\"\n        valid_attachment_value = \"Yes\"\n        document_type_value = \"\"\n\n        if not downloaded_path or not os.path.exists(downloaded_path):\n            attachment_missing_value = \"Yes\"\n            valid_attachment_value = \"No\"\n        else:\n            try:\n                with open(downloaded_path, 'rb') as file:\n                    content = file.read().strip()\n                    if not content:\n                        valid_attachment_value = \"No\"\n                    else:\n                        file_extension = downloaded_path.split('.')[-1].lower()\n                        valid_extensions = [\"pdf\", \"csv\", \"xlsx\"]\n                        document_type_value = file_extension if file_extension in valid_extensions else \"Unknown\"\n                        valid_attachment_value = \"Yes\" if file_extension in valid_extensions else \"No\"\n            except Exception as e:\n                log.error(f\"Error reading file: {e}\")\n                valid_attachment_value = \"No\"\n\n        attachment_paths.append(downloaded_path or download_location)\n        attachment_missing.append(attachment_missing_value)\n        valid_attachments.append(valid_attachment_value)\n        document_types.append(document_type_value)\n\n    documents = {\n        \"attachmentPath\": attachment_paths,\n        \"attachmentMissing\": attachment_missing,\n        \"validAttachment\": valid_attachments,\n        \"documentType\": document_types\n    }\n\n    if \"documents\" not in result_json:\n        result_json[\"documents\"] = []\n    result_json[\"documents\"].append(documents)\n\n    if \"actionRequired\" not in result_json:\n        result_json[\"actionRequired\"] = {\"action\": \"Verify and approve the uploaded documents\"}\n\n    return json.dumps(result_json)\n\nclass CustomComponent(Component):\n    display_name = \"Document Processor\"\n    description = \"Processes booking documents with DMS integration.\"\n    documentation = \"http://docs.langflow.org/components/custom\"\n    icon = \"code\"\n    name = \"DocumentProcessor\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"result_json\",\n            display_name=\"Result JSON\",\n            info=\"JSON result from LLM (e.g., {})\",\n            tool_mode=True,\n        ),\n        MessageTextInput(\n            name=\"input_data\",\n            display_name=\"Input Data\",\n            info=\"Input JSON with UUIDs (e.g., {'uuid': ['uuid1']})\",\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Output\", name=\"output\", method=\"build\"),\n    ]\n\n    def build(self) -> Data:\n        result_json = self.result_json\n        input_data = self.input_data\n\n        if result_json is None or input_data is None:\n            log.error(\"Required inputs 'result_json' or 'input_data' are missing\")\n            raise ValueError(\"Required inputs 'result_json' or 'input_data' are missing\")\n\n        # Parse if strings (remove these lines if guaranteed to be dicts)\n        if isinstance(result_json, str):\n            try:\n                result_json = json.loads(result_json)\n            except json.JSONDecodeError as e:\n                log.error(f\"Failed to parse result_json: {e}\")\n                raise ValueError(f\"Invalid result_json: {e}\")\n        if isinstance(input_data, str):\n            try:\n                input_data = json.loads(input_data)\n            except json.JSONDecodeError as e:\n                log.error(f\"Failed to parse input_data: {e}\")\n                raise ValueError(f\"Invalid input_data: {e}\")\n\n        result = process_documents(result_json, input_data)\n        data = Data(value=result)\n        self.status = data\n        return data", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "input_data": {"tool_mode": true, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "input_data", "value": "", "display_name": "Input Data", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "Input JSON with UUIDs (e.g., {'uuid': ['uuid1']})", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "result_json": {"tool_mode": true, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "result_json", "value": "", "display_name": "Result JSON", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "JSON result from LLM (e.g., {})", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Processes booking documents with DMS integration.", "icon": "code", "base_classes": ["Data"], "display_name": "Document Processor", "documentation": "http://docs.langflow.org/components/custom", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Data"], "selected": "Data", "name": "output", "hidden": null, "display_name": "Output", "method": "build", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "tool_mode": true}], "field_order": ["result_json", "input_data"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false, "lf_version": "1.1.5"}, "showNode": true, "type": "DocumentProcessor", "id": "DocumentProcessor-w7noZ"}, "selected": false, "measured": {"width": 320, "height": 331}, "dragging": false}, {"id": "ChatOutput-2mry3", "type": "genericNode", "position": {"x": 1412.933507528128, "y": -361.35701851657524}, "data": {"node": {"template": {"_type": "Component", "background_color": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "background_color", "value": "", "display_name": "Background Color", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "The background color of the icon.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "chat_icon": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "chat_icon", "value": "", "display_name": "Icon", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "The icon of the message.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import DropdownInput, MessageInput, MessageTextInput, Output\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        MessageInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            source_dict[\"source\"] = source\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n        message = self.input_value if isinstance(self.input_value, Message) else Message(text=self.input_value)\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "data_template": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "data_template", "value": "{text}", "display_name": "Data Template", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "input_value": {"trace_as_input": true, "tool_mode": false, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "input_value", "value": "", "display_name": "Text", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "Message to be passed as output.", "title_case": false, "type": "str", "_input_type": "MessageInput"}, "sender": {"tool_mode": false, "trace_as_metadata": true, "options": ["Machine", "User"], "options_metadata": [], "combobox": false, "dialog_inputs": {}, "required": false, "placeholder": "", "show": true, "name": "sender", "value": "Machine", "display_name": "Sender Type", "advanced": true, "dynamic": false, "info": "Type of sender.", "title_case": false, "type": "str", "_input_type": "DropdownInput"}, "sender_name": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sender_name", "value": "AI", "display_name": "Sender Name", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "Name of the sender.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "session_id": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "session_id", "value": "", "display_name": "Session ID", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "The session ID of the chat. If empty, the current session ID parameter will be used.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "should_store_message": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "should_store_message", "value": true, "display_name": "Store Messages", "advanced": true, "dynamic": false, "info": "Store the message in the history.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "text_color": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "text_color", "value": "", "display_name": "Text Color", "advanced": true, "input_types": ["Message"], "dynamic": false, "info": "The text color of the name", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}}, "description": "Display a chat message in the Playground.", "icon": "MessagesSquare", "base_classes": ["Message"], "display_name": "Chat Output", "documentation": "", "minimized": true, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "message", "hidden": null, "display_name": "Message", "method": "message_response", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "tool_mode": true}], "field_order": ["input_value", "should_store_message", "sender", "sender_name", "session_id", "data_template", "background_color", "chat_icon", "text_color"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "lf_version": "1.1.5"}, "showNode": true, "type": "ChatOutput", "id": "ChatOutput-2mry3"}, "selected": true, "measured": {"width": 320, "height": 229}, "dragging": false}, {"id": "JSONCleaner-RUPSE", "type": "genericNode", "position": {"x": -687.0989222962398, "y": -88.76861515486269}, "data": {"node": {"template": {"_type": "Component", "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "import json\nimport unicodedata\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, MessageTextInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass JSONCleaner(Component):\n    icon = \"braces\"\n    display_name = \"JSON Cleaner\"\n    description = (\n        \"Cleans the messy and sometimes incorrect JSON strings produced by LLMs \"\n        \"so that they are fully compliant with the JSON spec.\"\n    )\n\n    inputs = [\n        MessageTextInput(\n            name=\"json_str\", display_name=\"JSON String\", info=\"The JSON string to be cleaned.\", required=True\n        ),\n        BoolInput(\n            name=\"remove_control_chars\",\n            display_name=\"Remove Control Characters\",\n            info=\"Remove control characters from the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"normalize_unicode\",\n            display_name=\"Normalize Unicode\",\n            info=\"Normalize Unicode characters in the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"validate_json\",\n            display_name=\"Validate JSON\",\n            info=\"Validate the JSON string to ensure it is well-formed.\",\n            required=False,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Cleaned JSON String\", name=\"output\", method=\"clean_json\"),\n    ]\n\n    def clean_json(self) -> Message:\n        try:\n            from json_repair import repair_json\n        except ImportError as e:\n            msg = \"Could not import the json_repair package. Please install it with `pip install json_repair`.\"\n            raise ImportError(msg) from e\n\n        \"\"\"Clean the input JSON string based on provided options and return the cleaned JSON string.\"\"\"\n        json_str = self.json_str\n        remove_control_chars = self.remove_control_chars\n        normalize_unicode = self.normalize_unicode\n        validate_json = self.validate_json\n\n        start = json_str.find(\"{\")\n        end = json_str.rfind(\"}\")\n        if start == -1 or end == -1:\n            msg = \"Invalid JSON string: Missing '{' or '}'\"\n            raise ValueError(msg)\n        try:\n            json_str = json_str[start : end + 1]\n\n            if remove_control_chars:\n                json_str = self._remove_control_characters(json_str)\n            if normalize_unicode:\n                json_str = self._normalize_unicode(json_str)\n            if validate_json:\n                json_str = self._validate_json(json_str)\n\n            cleaned_json_str = repair_json(json_str)\n            result = str(cleaned_json_str)\n\n            self.status = result\n            return Message(text=result)\n        except Exception as e:\n            msg = f\"Error cleaning JSON string: {e}\"\n            raise ValueError(msg) from e\n\n    def _remove_control_characters(self, s: str) -> str:\n        \"\"\"Remove control characters from the string.\"\"\"\n        return s.translate(self.translation_table)\n\n    def _normalize_unicode(self, s: str) -> str:\n        \"\"\"Normalize Unicode characters in the string.\"\"\"\n        return unicodedata.normalize(\"NFC\", s)\n\n    def _validate_json(self, s: str) -> str:\n        \"\"\"Validate the JSON string.\"\"\"\n        try:\n            json.loads(s)\n        except json.JSONDecodeError as e:\n            msg = f\"Invalid JSON string: {e}\"\n            raise ValueError(msg) from e\n        return s\n\n    def __init__(self, *args, **kwargs):\n        # Create a translation table that maps control characters to None\n        super().__init__(*args, **kwargs)\n        self.translation_table = str.maketrans(\"\", \"\", \"\".join(chr(i) for i in range(32)) + chr(127))\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "json_str": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "json_str", "value": "", "display_name": "JSON String", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "The JSON string to be cleaned.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "normalize_unicode": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "normalize_unicode", "value": false, "display_name": "Normalize Unicode", "advanced": false, "dynamic": false, "info": "Normalize Unicode characters in the JSON string.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "remove_control_chars": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "remove_control_chars", "value": false, "display_name": "Remove Control Characters", "advanced": false, "dynamic": false, "info": "Remove control characters from the JSON string.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "validate_json": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "validate_json", "value": false, "display_name": "Validate JSON", "advanced": false, "dynamic": false, "info": "Validate the JSON string to ensure it is well-formed.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}}, "description": "Cleans the messy and sometimes incorrect JSON strings produced by LLMs so that they are fully compliant with the JSON spec.", "icon": "braces", "base_classes": ["Message"], "display_name": "JSON Cleaner", "documentation": "", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "output", "hidden": null, "display_name": "Cleaned JSON String", "method": "clean_json", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "tool_mode": true}], "field_order": ["json_str", "remove_control_chars", "normalize_unicode", "validate_json"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "lf_version": "1.1.5"}, "showNode": true, "type": "JSONCleaner", "id": "JSONCleaner-RUPSE"}, "selected": false, "measured": {"width": 320, "height": 395}, "dragging": false}, {"id": "ParseData-R6L8T", "type": "genericNode", "position": {"x": 142.76876574977962, "y": 34.68332963599515}, "data": {"node": {"template": {"_type": "Component", "data": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "trace_as_input": true, "required": true, "placeholder": "", "show": true, "name": "data", "value": "", "display_name": "Data", "advanced": false, "input_types": ["Data"], "dynamic": false, "info": "The JSON-like dictionary with data nested under 'value' key to convert to a message.", "title_case": false, "type": "other", "_input_type": "DataInput"}, "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "from langflow.custom import Component\nfrom langflow.io import DataInput, Output, StrInput\nfrom langflow.schema import Data\nfrom langflow.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Data to Message\"\n    description = \"Convert a nested JSON-like dictionary (under 'value' key) into a single Message with formatted key-value pairs.\"\n    icon = \"message-square\"\n    name = \"ParseData\"\n\n    inputs = [\n        DataInput(\n            name=\"data\",\n            display_name=\"Data\",\n            info=\"The JSON-like dictionary with data nested under 'value' key to convert to a message.\",\n            is_list=False,  # Single dictionary input\n            required=True\n        ),\n        StrInput(\n            name=\"sep\",\n            display_name=\"Separator\",\n            info=\"The separator to use between key-value pairs.\",\n            value=\"\\n\",\n            advanced=True\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"text\",\n            info=\"Nested dictionary (from 'value') formatted into a single Message, with key-value pairs separated by Separator.\",\n            method=\"parse_data\",\n        ),\n    ]\n\n    def _clean_args(self) -> tuple[Data, str]:\n        # Handle single dictionary input, convert to Data object if needed\n        data = self.data\n        if isinstance(data, dict):\n            # Extract the nested dictionary under 'value' key\n            data = data.get(\"value\", data)  # Fallback to full dict if 'value' not present\n            data = Data(data)  # Wrap dictionary in Data object\n        elif not isinstance(data, Data):\n            raise ValueError(\"Input must be a dictionary or Data object\")\n        sep = self.sep\n        return data, sep\n\n    def parse_data(self) -> Message:\n        data, sep = self._clean_args()\n        \n        # Convert Data object to dictionary for processing\n        data_dict = data if isinstance(data, dict) else data.data  # Assuming Data has a .data attribute\n        \n        # Format key-value pairs into a readable string with recursion for nested structures\n        def format_value(value, indent=0):\n            indent_str = \"  \" * indent\n            if isinstance(value, dict):\n                return sep.join(f\"{indent_str}{k}: {format_value(v, indent + 1)}\" for k, v in value.items())\n            elif isinstance(value, list):\n                return sep.join(f\"{indent_str}- {format_value(item, indent + 1)}\" for item in value)\n            else:\n                return str(value)\n\n        result_string = sep.join(f\"{key}: {format_value(value, 1)}\" for key, value in data_dict.items())\n        \n        if not result_string.strip():\n            result_string = \"No valid data found.\"\n        self.status = result_string\n        return Message(text=result_string)", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "sep": {"tool_mode": false, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "sep", "value": "\n", "display_name": "Separator", "advanced": true, "dynamic": false, "info": "The separator to use between key-value pairs.", "title_case": false, "type": "str", "_input_type": "StrInput"}}, "description": "Convert a nested JSON-like dictionary (under 'value' key) into a single Message with formatted key-value pairs.", "icon": "message-square", "base_classes": ["Message"], "display_name": "Data to Message", "documentation": "", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "text", "hidden": null, "display_name": "Message", "method": "parse_data", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "tool_mode": true}], "field_order": ["data", "sep"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false, "lf_version": "1.1.5"}, "showNode": true, "type": "ParseData", "id": "ParseData-R6L8T"}, "selected": false, "measured": {"width": 320, "height": 231}, "dragging": false}, {"id": "JSONCleaner-XA5hH", "type": "genericNode", "position": {"x": 538.8407998245169, "y": 117.74172937507521}, "data": {"node": {"template": {"_type": "Component", "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "import json\nimport unicodedata\n\nfrom langflow.custom import Component\nfrom langflow.inputs import BoolInput, MessageTextInput\nfrom langflow.schema.message import Message\nfrom langflow.template import Output\n\n\nclass JSONCleaner(Component):\n    icon = \"braces\"\n    display_name = \"JSON Cleaner\"\n    description = (\n        \"Cleans the messy and sometimes incorrect JSON strings produced by LLMs \"\n        \"so that they are fully compliant with the JSON spec.\"\n    )\n\n    inputs = [\n        MessageTextInput(\n            name=\"json_str\", display_name=\"JSON String\", info=\"The JSON string to be cleaned.\", required=True\n        ),\n        BoolInput(\n            name=\"remove_control_chars\",\n            display_name=\"Remove Control Characters\",\n            info=\"Remove control characters from the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"normalize_unicode\",\n            display_name=\"Normalize Unicode\",\n            info=\"Normalize Unicode characters in the JSON string.\",\n            required=False,\n        ),\n        BoolInput(\n            name=\"validate_json\",\n            display_name=\"Validate JSON\",\n            info=\"Validate the JSON string to ensure it is well-formed.\",\n            required=False,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Cleaned JSON String\", name=\"output\", method=\"clean_json\"),\n    ]\n\n    def clean_json(self) -> Message:\n        try:\n            from json_repair import repair_json\n        except ImportError as e:\n            msg = \"Could not import the json_repair package. Please install it with `pip install json_repair`.\"\n            raise ImportError(msg) from e\n\n        \"\"\"Clean the input JSON string based on provided options and return the cleaned JSON string.\"\"\"\n        json_str = self.json_str\n        remove_control_chars = self.remove_control_chars\n        normalize_unicode = self.normalize_unicode\n        validate_json = self.validate_json\n\n        start = json_str.find(\"{\")\n        end = json_str.rfind(\"}\")\n        if start == -1 or end == -1:\n            msg = \"Invalid JSON string: Missing '{' or '}'\"\n            raise ValueError(msg)\n        try:\n            json_str = json_str[start : end + 1]\n\n            if remove_control_chars:\n                json_str = self._remove_control_characters(json_str)\n            if normalize_unicode:\n                json_str = self._normalize_unicode(json_str)\n            if validate_json:\n                json_str = self._validate_json(json_str)\n\n            cleaned_json_str = repair_json(json_str)\n            result = str(cleaned_json_str)\n\n            self.status = result\n            return Message(text=result)\n        except Exception as e:\n            msg = f\"Error cleaning JSON string: {e}\"\n            raise ValueError(msg) from e\n\n    def _remove_control_characters(self, s: str) -> str:\n        \"\"\"Remove control characters from the string.\"\"\"\n        return s.translate(self.translation_table)\n\n    def _normalize_unicode(self, s: str) -> str:\n        \"\"\"Normalize Unicode characters in the string.\"\"\"\n        return unicodedata.normalize(\"NFC\", s)\n\n    def _validate_json(self, s: str) -> str:\n        \"\"\"Validate the JSON string.\"\"\"\n        try:\n            json.loads(s)\n        except json.JSONDecodeError as e:\n            msg = f\"Invalid JSON string: {e}\"\n            raise ValueError(msg) from e\n        return s\n\n    def __init__(self, *args, **kwargs):\n        # Create a translation table that maps control characters to None\n        super().__init__(*args, **kwargs)\n        self.translation_table = str.maketrans(\"\", \"\", \"\".join(chr(i) for i in range(32)) + chr(127))\n", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "json_str": {"tool_mode": false, "trace_as_input": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": true, "placeholder": "", "show": true, "name": "json_str", "value": "", "display_name": "JSON String", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "The JSON string to be cleaned.", "title_case": false, "type": "str", "_input_type": "MessageTextInput"}, "normalize_unicode": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "normalize_unicode", "value": false, "display_name": "Normalize Unicode", "advanced": false, "dynamic": false, "info": "Normalize Unicode characters in the JSON string.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "remove_control_chars": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "remove_control_chars", "value": false, "display_name": "Remove Control Characters", "advanced": false, "dynamic": false, "info": "Remove control characters from the JSON string.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}, "validate_json": {"tool_mode": false, "trace_as_metadata": true, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "validate_json", "value": false, "display_name": "Validate JSON", "advanced": false, "dynamic": false, "info": "Validate the JSON string to ensure it is well-formed.", "title_case": false, "type": "bool", "_input_type": "BoolInput"}}, "description": "Cleans the messy and sometimes incorrect JSON strings produced by LLMs so that they are fully compliant with the JSON spec.", "icon": "braces", "base_classes": ["Message"], "display_name": "JSON Cleaner", "documentation": "", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "output", "hidden": null, "display_name": "Cleaned JSON String", "method": "clean_json", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "tool_mode": true}], "field_order": ["json_str", "remove_control_chars", "normalize_unicode", "validate_json"], "beta": false, "legacy": false, "edited": false, "metadata": {}, "tool_mode": false, "lf_version": "1.1.5"}, "showNode": true, "type": "JSONCleaner", "id": "JSONCleaner-XA5hH"}, "selected": false, "measured": {"width": 320, "height": 395}, "dragging": false}, {"id": "TextInput-yd11R", "type": "genericNode", "position": {"x": 937.4638523047711, "y": 46.47911191127141}, "data": {"node": {"template": {"_type": "Component", "code": {"type": "code", "required": true, "placeholder": "", "list": false, "show": true, "multiline": true, "value": "import json\nimport copy\nfrom langflow.base.io.text import TextComponent\nfrom langflow.io import MultilineInput, Output\nfrom langflow.schema.message import Message\n\n\nclass TextInputComponent(TextComponent):\n    display_name = \"Text Input\"\n    description = \"Get text inputs from the Playground.\"\n    icon = \"type\"\n    name = \"TextInput\"\n\n    # Define the base structure as an instance variable\n    base = {\n        \"mailType\": \"\",\n        \"enquiry\": {\n            \"contentPresent\": \"\",\n            \"enquiryType\": \"\",\n            \"validEnquiry\": \"\"\n        },\n        \"rateCloud\": {\n            \"attachementPath\": [],\n            \"attachmentMissing\": \"\",\n            \"validAttachment\": [],\n            \"documentType\": []\n        },\n        \"orderFullFillment\": {\n            \"attachementPath\": [],\n            \"attachmentMissing\": \"\",\n            \"validAttachment\": [],\n            \"documentType\": []\n        },\n        \"helpDesk\": {\n            \"issueType\": \"\"\n        }\n    }\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Text to be passed as input.\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"text\", method=\"text_response\"),\n    ]\n\n    def base_classify(self, result_json):\n        print(\"Successfully entered into base classify.\")\n        \n        # Check if result_json is a string and load it, otherwise skip\n        if isinstance(result_json, str):\n            result_json = json.loads(result_json) \n        print(\"Result json:\", result_json)\n\n        mail = result_json.get('mailType').lower()\n        print(\"Mail Type:\", mail)\n\n        base = copy.deepcopy(self.base) \n        base['mailType'] = mail\n        if 'documents' in result_json and isinstance(result_json['documents'], list):\n            # Assuming documents is a list, take the first document (adjust if needed)\n            document_info = result_json['documents'][0] if result_json['documents'] else {}\n\n            attachment_path = document_info.get(\"attachmentPath\")\n            attachment_missing = document_info.get('attachmentMissing')\n            valid_attachment = document_info.get('validAttachment')\n            document_type = document_info.get('documentType')\n\n            print(\"Attachment Missing:\", attachment_missing)\n            print(\"Valid Attachment:\", valid_attachment)\n            print(\"Document Type:\", document_type)\n\n            if mail == \"enquiry\":\n                base['enquiry']['contentPresent'] = result_json.get('contentPresentEnquiry')\n                base['enquiry']['enquiryType'] = result_json.get('enquiryType')\n                base['enquiry']['validEnquiry'] = result_json.get('validEnquiry')\n                print(\"Enquiry data added:\", base['enquiry'])\n            if mail == \"ratecloud\":\n                base['rateCloud']['attachementPath'] = attachment_path\n                base['rateCloud']['attachmentMissing'] = attachment_missing\n                base['rateCloud']['validAttachment'] = valid_attachment\n                base['rateCloud']['documentType'] = document_type\n            if mail == \"orderfulfillment\":\n                base['orderFullFillment']['attachementPath'] = attachment_path\n                base['orderFullFillment']['attachmentMissing'] = attachment_missing\n                base['orderFullFillment']['validAttachment'] = valid_attachment\n                base['orderFullFillment']['documentType'] = document_type\n                print(\"OrderFullFillment data added:\", base['orderFullFillment'])\n            if mail == \"helpdesk\":\n                base['helpDesk']['issueType'] = result_json.get('issueType')\n                print(\"HelpDesk data added:\", base['helpDesk'])\n\n        print(\"Updated Base:\", json.dumps(base, indent=4))\n\n        return base\n\n    def text_response(self) -> Message:\n        # Process the input_value using base_classify\n        classified_result = self.base_classify(self.input_value)\n        # Return the result as a Message object, converting to JSON string\n        return Message(\n            text=json.dumps(classified_result, indent=4),\n        )", "fileTypes": [], "file_path": "", "password": false, "name": "code", "advanced": true, "dynamic": true, "info": "", "load_from_db": false, "title_case": false}, "input_value": {"tool_mode": false, "trace_as_input": true, "multiline": true, "trace_as_metadata": true, "load_from_db": false, "list": false, "list_add_label": "Add More", "required": false, "placeholder": "", "show": true, "name": "input_value", "value": "", "display_name": "Text", "advanced": false, "input_types": ["Message"], "dynamic": false, "info": "Text to be passed as input.", "title_case": false, "type": "str", "_input_type": "MultilineInput"}}, "description": "Get text inputs from the Playground.", "icon": "type", "base_classes": ["Message"], "display_name": "Text Input", "documentation": "", "minimized": false, "custom_fields": {}, "output_types": [], "pinned": false, "conditional_paths": [], "frozen": false, "outputs": [{"types": ["Message"], "selected": "Message", "name": "text", "hidden": null, "display_name": "Message", "method": "text_response", "value": "__UNDEFINED__", "cache": true, "required_inputs": null, "allows_loop": false, "tool_mode": true}], "field_order": ["input_value"], "beta": false, "legacy": false, "edited": true, "metadata": {}, "tool_mode": false, "lf_version": "1.1.5"}, "showNode": true, "type": "TextInput", "id": "TextInput-yd11R"}, "selected": false, "measured": {"width": 320, "height": 229}}], "edges": [{"source": "Prompt-TI8xV", "sourceHandle": "{\u0153dataType\u0153:\u0153Prompt\u0153,\u0153id\u0153:\u0153Prompt-TI8xV\u0153,\u0153name\u0153:\u0153prompt\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "OpenAIModel-bcpME", "targetHandle": "{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153OpenAIModel-bcpME\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "input_value", "id": "OpenAIModel-bcpME", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "Prompt", "id": "Prompt-TI8xV", "name": "prompt", "output_types": ["Message"]}}, "id": "reactflow__edge-Prompt-TI8xV{\u0153dataType\u0153:\u0153Prompt\u0153,\u0153id\u0153:\u0153Prompt-TI8xV\u0153,\u0153name\u0153:\u0153prompt\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-OpenAIModel-bcpME{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153OpenAIModel-bcpME\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "selected": false, "animated": false, "className": ""}, {"source": "TextInput-BBQPu", "sourceHandle": "{\u0153dataType\u0153:\u0153TextInput\u0153,\u0153id\u0153:\u0153TextInput-BBQPu\u0153,\u0153name\u0153:\u0153text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "Prompt-TI8xV", "targetHandle": "{\u0153fieldName\u0153:\u0153content\u0153,\u0153id\u0153:\u0153Prompt-TI8xV\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "content", "id": "Prompt-TI8xV", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "TextInput", "id": "TextInput-BBQPu", "name": "text", "output_types": ["Message"]}}, "id": "reactflow__edge-TextInput-BBQPu{\u0153dataType\u0153:\u0153TextInput\u0153,\u0153id\u0153:\u0153TextInput-BBQPu\u0153,\u0153name\u0153:\u0153text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-Prompt-TI8xV{\u0153fieldName\u0153:\u0153content\u0153,\u0153id\u0153:\u0153Prompt-TI8xV\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "animated": false, "className": "", "selected": false}, {"source": "TextInput-BBQPu", "sourceHandle": "{\u0153dataType\u0153:\u0153TextInput\u0153,\u0153id\u0153:\u0153TextInput-BBQPu\u0153,\u0153name\u0153:\u0153text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "JSONCleaner-RUPSE", "targetHandle": "{\u0153fieldName\u0153:\u0153json_str\u0153,\u0153id\u0153:\u0153JSONCleaner-RUPSE\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "json_str", "id": "JSONCleaner-RUPSE", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "TextInput", "id": "TextInput-BBQPu", "name": "text", "output_types": ["Message"]}}, "id": "reactflow__edge-TextInput-BBQPu{\u0153dataType\u0153:\u0153TextInput\u0153,\u0153id\u0153:\u0153TextInput-BBQPu\u0153,\u0153name\u0153:\u0153text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-JSONCleaner-RUPSE{\u0153fieldName\u0153:\u0153json_str\u0153,\u0153id\u0153:\u0153JSONCleaner-RUPSE\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "animated": false, "className": "", "selected": false}, {"source": "JSONCleaner-mnhzp", "sourceHandle": "{\u0153dataType\u0153:\u0153JSONCleaner\u0153,\u0153id\u0153:\u0153JSONCleaner-mnhzp\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "DocumentProcessor-w7noZ", "targetHandle": "{\u0153fieldName\u0153:\u0153result_json\u0153,\u0153id\u0153:\u0153DocumentProcessor-w7noZ\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "result_json", "id": "DocumentProcessor-w7noZ", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "JSONCleaner", "id": "JSONCleaner-mnhzp", "name": "output", "output_types": ["Message"]}}, "id": "reactflow__edge-JSONCleaner-mnhzp{\u0153dataType\u0153:\u0153JSONCleaner\u0153,\u0153id\u0153:\u0153JSONCleaner-mnhzp\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-DocumentProcessor-w7noZ{\u0153fieldName\u0153:\u0153result_json\u0153,\u0153id\u0153:\u0153DocumentProcessor-w7noZ\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "animated": false, "className": "", "selected": false}, {"source": "JSONCleaner-RUPSE", "sourceHandle": "{\u0153dataType\u0153:\u0153JSONCleaner\u0153,\u0153id\u0153:\u0153JSONCleaner-RUPSE\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "DocumentProcessor-w7noZ", "targetHandle": "{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153DocumentProcessor-w7noZ\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "input_data", "id": "DocumentProcessor-w7noZ", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "JSONCleaner", "id": "JSONCleaner-RUPSE", "name": "output", "output_types": ["Message"]}}, "id": "reactflow__edge-JSONCleaner-RUPSE{\u0153dataType\u0153:\u0153JSONCleaner\u0153,\u0153id\u0153:\u0153JSONCleaner-RUPSE\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-DocumentProcessor-w7noZ{\u0153fieldName\u0153:\u0153input_data\u0153,\u0153id\u0153:\u0153DocumentProcessor-w7noZ\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "animated": false, "className": "", "selected": false}, {"source": "DocumentProcessor-w7noZ", "sourceHandle": "{\u0153dataType\u0153:\u0153DocumentProcessor\u0153,\u0153id\u0153:\u0153DocumentProcessor-w7noZ\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}", "target": "ParseData-R6L8T", "targetHandle": "{\u0153fieldName\u0153:\u0153data\u0153,\u0153id\u0153:\u0153ParseData-R6L8T\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "data": {"targetHandle": {"fieldName": "data", "id": "ParseData-R6L8T", "inputTypes": ["Data"], "type": "other"}, "sourceHandle": {"dataType": "DocumentProcessor", "id": "DocumentProcessor-w7noZ", "name": "output", "output_types": ["Data"]}}, "id": "reactflow__edge-DocumentProcessor-w7noZ{\u0153dataType\u0153:\u0153DocumentProcessor\u0153,\u0153id\u0153:\u0153DocumentProcessor-w7noZ\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Data\u0153]}-ParseData-R6L8T{\u0153fieldName\u0153:\u0153data\u0153,\u0153id\u0153:\u0153ParseData-R6L8T\u0153,\u0153inputTypes\u0153:[\u0153Data\u0153],\u0153type\u0153:\u0153other\u0153}", "animated": false, "className": "", "selected": false}, {"source": "ParseData-R6L8T", "sourceHandle": "{\u0153dataType\u0153:\u0153ParseData\u0153,\u0153id\u0153:\u0153ParseData-R6L8T\u0153,\u0153name\u0153:\u0153text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "JSONCleaner-XA5hH", "targetHandle": "{\u0153fieldName\u0153:\u0153json_str\u0153,\u0153id\u0153:\u0153JSONCleaner-XA5hH\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "json_str", "id": "JSONCleaner-XA5hH", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "ParseData", "id": "ParseData-R6L8T", "name": "text", "output_types": ["Message"]}}, "id": "reactflow__edge-ParseData-R6L8T{\u0153dataType\u0153:\u0153ParseData\u0153,\u0153id\u0153:\u0153ParseData-R6L8T\u0153,\u0153name\u0153:\u0153text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-JSONCleaner-XA5hH{\u0153fieldName\u0153:\u0153json_str\u0153,\u0153id\u0153:\u0153JSONCleaner-XA5hH\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "animated": false, "className": "", "selected": false}, {"source": "OpenAIModel-bcpME", "sourceHandle": "{\u0153dataType\u0153:\u0153OpenAIModel\u0153,\u0153id\u0153:\u0153OpenAIModel-bcpME\u0153,\u0153name\u0153:\u0153text_output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "JSONCleaner-mnhzp", "targetHandle": "{\u0153fieldName\u0153:\u0153json_str\u0153,\u0153id\u0153:\u0153JSONCleaner-mnhzp\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "json_str", "id": "JSONCleaner-mnhzp", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "OpenAIModel", "id": "OpenAIModel-bcpME", "name": "text_output", "output_types": ["Message"]}}, "id": "xy-edge__OpenAIModel-bcpME{\u0153dataType\u0153:\u0153OpenAIModel\u0153,\u0153id\u0153:\u0153OpenAIModel-bcpME\u0153,\u0153name\u0153:\u0153text_output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-JSONCleaner-mnhzp{\u0153fieldName\u0153:\u0153json_str\u0153,\u0153id\u0153:\u0153JSONCleaner-mnhzp\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "animated": false, "className": ""}, {"source": "JSONCleaner-XA5hH", "sourceHandle": "{\u0153dataType\u0153:\u0153JSONCleaner\u0153,\u0153id\u0153:\u0153JSONCleaner-XA5hH\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "TextInput-yd11R", "targetHandle": "{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153TextInput-yd11R\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "input_value", "id": "TextInput-yd11R", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "JSONCleaner", "id": "JSONCleaner-XA5hH", "name": "output", "output_types": ["Message"]}}, "id": "xy-edge__JSONCleaner-XA5hH{\u0153dataType\u0153:\u0153JSONCleaner\u0153,\u0153id\u0153:\u0153JSONCleaner-XA5hH\u0153,\u0153name\u0153:\u0153output\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-TextInput-yd11R{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153TextInput-yd11R\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "animated": false, "className": ""}, {"source": "TextInput-yd11R", "sourceHandle": "{\u0153dataType\u0153:\u0153TextInput\u0153,\u0153id\u0153:\u0153TextInput-yd11R\u0153,\u0153name\u0153:\u0153text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}", "target": "ChatOutput-2mry3", "targetHandle": "{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153ChatOutput-2mry3\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "data": {"targetHandle": {"fieldName": "input_value", "id": "ChatOutput-2mry3", "inputTypes": ["Message"], "type": "str"}, "sourceHandle": {"dataType": "TextInput", "id": "TextInput-yd11R", "name": "text", "output_types": ["Message"]}}, "id": "xy-edge__TextInput-yd11R{\u0153dataType\u0153:\u0153TextInput\u0153,\u0153id\u0153:\u0153TextInput-yd11R\u0153,\u0153name\u0153:\u0153text\u0153,\u0153output_types\u0153:[\u0153Message\u0153]}-ChatOutput-2mry3{\u0153fieldName\u0153:\u0153input_value\u0153,\u0153id\u0153:\u0153ChatOutput-2mry3\u0153,\u0153inputTypes\u0153:[\u0153Message\u0153],\u0153type\u0153:\u0153str\u0153}", "animated": false, "className": ""}], "viewport": {"x": 369.2607026695114, "y": 324.054727348194, "zoom": 0.3454537555185813}}, "is_component": false, "updated_at": "2025-03-18T06:02:20+00:00", "webhook": false, "endpoint_name": null, "tags": null, "locked": false, "id": "f93fbfe6-70d8-4ea3-bfe3-09f15f7dcd8d", "user_id": "24e4b9b7-973b-4d32-8618-2f1b6b6b61f9", "folder_id": "a91f2823-6f82-4a9b-b6ed-222b8ef6e7f1"}